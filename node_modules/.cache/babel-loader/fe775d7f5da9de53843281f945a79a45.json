{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAssociatedTokenAddress = exports.getMinimumBalanceForRentExemptMint = exports.getMint = exports.MINT_SIZE = exports.MintLayout = void 0;\n\nconst buffer_layout_1 = require(\"@solana/buffer-layout\");\n\nconst buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst constants_1 = require(\"../constants\");\n\nconst errors_1 = require(\"../errors\");\n/** Buffer layout for de/serializing a mint */\n\n\nexports.MintLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u32)('mintAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('mintAuthority'), (0, buffer_layout_utils_1.u64)('supply'), (0, buffer_layout_1.u8)('decimals'), (0, buffer_layout_utils_1.bool)('isInitialized'), (0, buffer_layout_1.u32)('freezeAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('freezeAuthority')]);\n/** Byte length of a mint */\n\nexports.MINT_SIZE = exports.MintLayout.span;\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\n\nfunction getMint(connection, address, commitment) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, function* () {\n    const info = yield connection.getAccountInfo(address, commitment);\n    if (!info) throw new errors_1.TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new errors_1.TokenInvalidAccountOwnerError();\n    if (info.data.length != exports.MINT_SIZE) throw new errors_1.TokenInvalidAccountSizeError();\n    const rawMint = exports.MintLayout.decode(info.data);\n    return {\n      address,\n      mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n      supply: rawMint.supply,\n      decimals: rawMint.decimals,\n      isInitialized: rawMint.isInitialized,\n      freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null\n    };\n  });\n}\n\nexports.getMint = getMint;\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nfunction getMinimumBalanceForRentExemptMint(connection, commitment) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return yield connection.getMinimumBalanceForRentExemption(exports.MINT_SIZE, commitment);\n  });\n}\n\nexports.getMinimumBalanceForRentExemptMint = getMinimumBalanceForRentExemptMint;\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\n\nfunction getAssociatedTokenAddress(mint, owner) {\n  let allowOwnerOffCurve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.TOKEN_PROGRAM_ID;\n  let associatedTokenProgramId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : constants_1.ASSOCIATED_TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer())) throw new errors_1.TokenOwnerOffCurveError();\n    const [address] = yield web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n    return address;\n  });\n}\n\nexports.getAssociatedTokenAddress = getAssociatedTokenAddress;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;AAqCA;;;AACaA,qBAAa,4BAAgB,CACtC,yBAAI,qBAAJ,CADsC,EAEtC,qCAAU,eAAV,CAFsC,EAGtC,+BAAI,QAAJ,CAHsC,EAItC,wBAAG,UAAH,CAJsC,EAKtC,gCAAK,eAAL,CALsC,EAMtC,yBAAI,uBAAJ,CANsC,EAOtC,qCAAU,iBAAV,CAPsC,CAAhB,CAAb;AAUb;;AACaA,oBAAYA,mBAAWC,IAAvB;AAEb;;;;;;;;;;;AAUA,SAAsBC,OAAtB,CACIC,UADJ,EAEIC,OAFJ,EAGIC,UAHJ,EAIgC;AAAA,MAA5BC,SAA4B,uEAAhBC,4BAAgB;;AAE5B,UAAMC,IAAI,GAAG,MAAML,UAAU,CAACM,cAAX,CAA0BL,OAA1B,EAAmCC,UAAnC,CAAnB;AACA,QAAI,CAACG,IAAL,EAAW,MAAM,IAAIE,kCAAJ,EAAN;AACX,QAAI,CAACF,IAAI,CAACG,KAAL,CAAWC,MAAX,CAAkBN,SAAlB,CAAL,EAAmC,MAAM,IAAII,sCAAJ,EAAN;AACnC,QAAIF,IAAI,CAACK,IAAL,CAAUC,MAAV,IAAoBd,iBAAxB,EAAmC,MAAM,IAAIU,qCAAJ,EAAN;AAEnC,UAAMK,OAAO,GAAGf,mBAAWgB,MAAX,CAAkBR,IAAI,CAACK,IAAvB,CAAhB;AAEA,WAAO;AACHT,aADG;AAEHa,mBAAa,EAAEF,OAAO,CAACG,mBAAR,GAA8BH,OAAO,CAACE,aAAtC,GAAsD,IAFlE;AAGHE,YAAM,EAAEJ,OAAO,CAACI,MAHb;AAIHC,cAAQ,EAAEL,OAAO,CAACK,QAJf;AAKHC,mBAAa,EAAEN,OAAO,CAACM,aALpB;AAMHC,qBAAe,EAAEP,OAAO,CAACQ,qBAAR,GAAgCR,OAAO,CAACO,eAAxC,GAA0D;AANxE,KAAP;AAQH;AAAA;;AArBDtB;AAuBA;;;;;;;;AAOA,SAAsBwB,kCAAtB,CACIrB,UADJ,EAEIE,UAFJ,EAE2B;;AAEvB,WAAO,MAAMF,UAAU,CAACsB,iCAAX,CAA6CzB,iBAA7C,EAAwDK,UAAxD,CAAb;AACH;AAAA;;AALDL;AAOA;;;;;;;;;;;;AAWA,SAAsB0B,yBAAtB,CACIC,IADJ,EAEIhB,KAFJ,EAK0D;AAAA,MAFtDiB,kBAEsD,uEAFjC,KAEiC;AAAA,MADtDtB,SACsD,uEAD1CC,4BAC0C;AAAA,MAAtDsB,wBAAsD,uEAA3BtB,uCAA2B;;AAEtD,QAAI,CAACqB,kBAAD,IAAuB,CAACE,oBAAUC,SAAV,CAAoBpB,KAAK,CAACqB,QAAN,EAApB,CAA5B,EAAmE,MAAM,IAAItB,gCAAJ,EAAN;AAEnE,UAAM,CAACN,OAAD,IAAY,MAAM0B,oBAAUG,kBAAV,CACpB,CAACtB,KAAK,CAACqB,QAAN,EAAD,EAAmB1B,SAAS,CAAC0B,QAAV,EAAnB,EAAyCL,IAAI,CAACK,QAAL,EAAzC,CADoB,EAEpBH,wBAFoB,CAAxB;AAKA,WAAOzB,OAAP;AACH;AAAA;;AAfDJ","names":["exports","span","getMint","connection","address","commitment","programId","constants_1","info","getAccountInfo","errors_1","owner","equals","data","length","rawMint","decode","mintAuthority","mintAuthorityOption","supply","decimals","isInitialized","freezeAuthority","freezeAuthorityOption","getMinimumBalanceForRentExemptMint","getMinimumBalanceForRentExemption","getAssociatedTokenAddress","mint","allowOwnerOffCurve","associatedTokenProgramId","web3_js_1","isOnCurve","toBuffer","findProgramAddress"],"sources":["/home/rajeev/Internship/Get-NFTs-in-Wallet-Adapter/node_modules/@solana/spl-token/src/state/mint.ts"],"sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidAccountSizeError,\n    TokenOwnerOffCurveError,\n} from '../errors';\n\n/** Information about a mint */\nexport interface Mint {\n    /** Address of the mint */\n    address: PublicKey;\n    /**\n     * Optional authority used to mint new tokens. The mint authority may only be provided during mint creation.\n     * If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.\n     */\n    mintAuthority: PublicKey | null;\n    /** Total supply of tokens */\n    supply: bigint;\n    /** Number of base 10 digits to the right of the decimal place */\n    decimals: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Optional authority to freeze token accounts */\n    freezeAuthority: PublicKey | null;\n}\n\n/** Mint as stored by the program */\nexport interface RawMint {\n    mintAuthorityOption: 1 | 0;\n    mintAuthority: PublicKey;\n    supply: bigint;\n    decimals: number;\n    isInitialized: boolean;\n    freezeAuthorityOption: 1 | 0;\n    freezeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct<RawMint>([\n    u32('mintAuthorityOption'),\n    publicKey('mintAuthority'),\n    u64('supply'),\n    u8('decimals'),\n    bool('isInitialized'),\n    u32('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nexport async function getMint(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Mint> {\n    const info = await connection.getAccountInfo(address, commitment);\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MINT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawMint = MintLayout.decode(info.data);\n\n    return {\n        address,\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n        supply: rawMint.supply,\n        decimals: rawMint.decimals,\n        isInitialized: rawMint.isInitialized,\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n    };\n}\n\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMint(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MINT_SIZE, commitment);\n}\n\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nexport async function getAssociatedTokenAddress(\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n\n    const [address] = await PublicKey.findProgramAddress(\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\n        associatedTokenProgramId\n    );\n\n    return address;\n}\n"]},"metadata":{},"sourceType":"script"}