{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMinimumBalanceForRentExemptMultisig = exports.getMultisig = exports.MULTISIG_SIZE = exports.MultisigLayout = void 0;\n\nconst buffer_layout_1 = require(\"@solana/buffer-layout\");\n\nconst buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\n\nconst constants_1 = require(\"../constants\");\n\nconst errors_1 = require(\"../errors\");\n/** Buffer layout for de/serializing a multisig */\n\n\nexports.MultisigLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('m'), (0, buffer_layout_1.u8)('n'), (0, buffer_layout_utils_1.bool)('isInitialized'), (0, buffer_layout_utils_1.publicKey)('signer1'), (0, buffer_layout_utils_1.publicKey)('signer2'), (0, buffer_layout_utils_1.publicKey)('signer3'), (0, buffer_layout_utils_1.publicKey)('signer4'), (0, buffer_layout_utils_1.publicKey)('signer5'), (0, buffer_layout_utils_1.publicKey)('signer6'), (0, buffer_layout_utils_1.publicKey)('signer7'), (0, buffer_layout_utils_1.publicKey)('signer8'), (0, buffer_layout_utils_1.publicKey)('signer9'), (0, buffer_layout_utils_1.publicKey)('signer10'), (0, buffer_layout_utils_1.publicKey)('signer11')]);\n/** Byte length of a multisig */\n\nexports.MULTISIG_SIZE = exports.MultisigLayout.span;\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\n\nfunction getMultisig(connection, address, commitment) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, function* () {\n    const info = yield connection.getAccountInfo(address, commitment);\n    if (!info) throw new errors_1.TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new errors_1.TokenInvalidAccountOwnerError();\n    if (info.data.length != exports.MULTISIG_SIZE) throw new errors_1.TokenInvalidAccountSizeError();\n    return Object.assign({\n      address\n    }, exports.MultisigLayout.decode(info.data));\n  });\n}\n\nexports.getMultisig = getMultisig;\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nfunction getMinimumBalanceForRentExemptMultisig(connection, commitment) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return yield connection.getMinimumBalanceForRentExemption(exports.MULTISIG_SIZE, commitment);\n  });\n}\n\nexports.getMinimumBalanceForRentExemptMultisig = getMinimumBalanceForRentExemptMultisig;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAEA;;AACA;AA6BA;;;AACaA,yBAAiB,4BAAoB,CAC9C,wBAAG,GAAH,CAD8C,EAE9C,wBAAG,GAAH,CAF8C,EAG9C,gCAAK,eAAL,CAH8C,EAI9C,qCAAU,SAAV,CAJ8C,EAK9C,qCAAU,SAAV,CAL8C,EAM9C,qCAAU,SAAV,CAN8C,EAO9C,qCAAU,SAAV,CAP8C,EAQ9C,qCAAU,SAAV,CAR8C,EAS9C,qCAAU,SAAV,CAT8C,EAU9C,qCAAU,SAAV,CAV8C,EAW9C,qCAAU,SAAV,CAX8C,EAY9C,qCAAU,SAAV,CAZ8C,EAa9C,qCAAU,UAAV,CAb8C,EAc9C,qCAAU,UAAV,CAd8C,CAApB,CAAjB;AAiBb;;AACaA,wBAAgBA,uBAAeC,IAA/B;AAEb;;;;;;;;;;;AAUA,SAAsBC,WAAtB,CACIC,UADJ,EAEIC,OAFJ,EAGIC,UAHJ,EAIgC;AAAA,MAA5BC,SAA4B,uEAAhBC,4BAAgB;;AAE5B,UAAMC,IAAI,GAAG,MAAML,UAAU,CAACM,cAAX,CAA0BL,OAA1B,EAAmCC,UAAnC,CAAnB;AACA,QAAI,CAACG,IAAL,EAAW,MAAM,IAAIE,kCAAJ,EAAN;AACX,QAAI,CAACF,IAAI,CAACG,KAAL,CAAWC,MAAX,CAAkBN,SAAlB,CAAL,EAAmC,MAAM,IAAII,sCAAJ,EAAN;AACnC,QAAIF,IAAI,CAACK,IAAL,CAAUC,MAAV,IAAoBd,qBAAxB,EAAuC,MAAM,IAAIU,qCAAJ,EAAN;AAEvC;AAASN;AAAT,OAAqBJ,uBAAee,MAAf,CAAsBP,IAAI,CAACK,IAA3B,CAArB;AACH;AAAA;;AAZDb;AAcA;;;;;;;;AAOA,SAAsBgB,sCAAtB,CACIb,UADJ,EAEIE,UAFJ,EAE2B;;AAEvB,WAAO,MAAMF,UAAU,CAACc,iCAAX,CAA6CjB,qBAA7C,EAA4DK,UAA5D,CAAb;AACH;AAAA;;AALDL","names":["exports","span","getMultisig","connection","address","commitment","programId","constants_1","info","getAccountInfo","errors_1","owner","equals","data","length","decode","getMinimumBalanceForRentExemptMultisig","getMinimumBalanceForRentExemption"],"sources":["/home/rajeev/Internship/Get-NFTs-in-Wallet-Adapter/node_modules/@solana/spl-token/src/state/multisig.ts"],"sourcesContent":["import { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors';\n\n/** Information about a multisig */\nexport interface Multisig {\n    /** Address of the multisig */\n    address: PublicKey;\n    /** Number of signers required */\n    m: number;\n    /** Number of possible signers, corresponds to the number of `signers` that are valid */\n    n: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Full set of signers, of which `n` are valid */\n    signer1: PublicKey;\n    signer2: PublicKey;\n    signer3: PublicKey;\n    signer4: PublicKey;\n    signer5: PublicKey;\n    signer6: PublicKey;\n    signer7: PublicKey;\n    signer8: PublicKey;\n    signer9: PublicKey;\n    signer10: PublicKey;\n    signer11: PublicKey;\n}\n\n/** Multisig as stored by the program */\nexport type RawMultisig = Omit<Multisig, 'address'>;\n\n/** Buffer layout for de/serializing a multisig */\nexport const MultisigLayout = struct<RawMultisig>([\n    u8('m'),\n    u8('n'),\n    bool('isInitialized'),\n    publicKey('signer1'),\n    publicKey('signer2'),\n    publicKey('signer3'),\n    publicKey('signer4'),\n    publicKey('signer5'),\n    publicKey('signer6'),\n    publicKey('signer7'),\n    publicKey('signer8'),\n    publicKey('signer9'),\n    publicKey('signer10'),\n    publicKey('signer11'),\n]);\n\n/** Byte length of a multisig */\nexport const MULTISIG_SIZE = MultisigLayout.span;\n\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\nexport async function getMultisig(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Multisig> {\n    const info = await connection.getAccountInfo(address, commitment);\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n\n    return { address, ...MultisigLayout.decode(info.data) };\n}\n\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMultisig(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n}\n"]},"metadata":{},"sourceType":"script"}