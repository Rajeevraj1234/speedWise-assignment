{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOrCreateAssociatedTokenAccount = void 0;\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst constants_1 = require(\"../constants\");\n\nconst errors_1 = require(\"../errors\");\n\nconst index_1 = require(\"../instructions/index\");\n\nconst index_2 = require(\"../state/index\");\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\n\n\nfunction getOrCreateAssociatedTokenAccount(connection, payer, mint, owner) {\n  let allowOwnerOffCurve = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let commitment = arguments.length > 5 ? arguments[5] : undefined;\n  let confirmOptions = arguments.length > 6 ? arguments[6] : undefined;\n  let programId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : constants_1.TOKEN_PROGRAM_ID;\n  let associatedTokenProgramId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : constants_1.ASSOCIATED_TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, function* () {\n    const associatedToken = yield (0, index_2.getAssociatedTokenAddress)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId); // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n\n    let account;\n\n    try {\n      account = yield (0, index_2.getAccount)(connection, associatedToken, commitment, programId);\n    } catch (error) {\n      // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n      // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n      // TokenInvalidAccountOwnerError in this code path.\n      if (error instanceof errors_1.TokenAccountNotFoundError || error instanceof errors_1.TokenInvalidAccountOwnerError) {\n        // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n        try {\n          const transaction = new web3_js_1.Transaction().add((0, index_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n          yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);\n        } catch (error) {// Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n          // instruction error if the associated account exists already.\n        } // Now this should always succeed\n\n\n        account = yield (0, index_2.getAccount)(connection, associatedToken, commitment, programId);\n      } else {\n        throw error;\n      }\n    }\n\n    if (!account.mint.equals(mint)) throw new errors_1.TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new errors_1.TokenInvalidOwnerError();\n    return account;\n  });\n}\n\nexports.getOrCreateAssociatedTokenAccount = getOrCreateAssociatedTokenAccount;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AASA;;AACA;;AAMA;;AACA;AAEA;;;;;;;;;;;;;;;;;AAeA,SAAsBA,iCAAtB,CACIC,UADJ,EAEIC,KAFJ,EAGIC,IAHJ,EAIIC,KAJJ,EAS0D;AAAA,MAJtDC,kBAIsD,uEAJjC,KAIiC;AAAA,MAHtDC,UAGsD;AAAA,MAFtDC,cAEsD;AAAA,MADtDC,SACsD,uEAD1CC,4BAC0C;AAAA,MAAtDC,wBAAsD,uEAA3BD,uCAA2B;;AAEtD,UAAME,eAAe,GAAG,MAAM,uCAC1BR,IAD0B,EAE1BC,KAF0B,EAG1BC,kBAH0B,EAI1BG,SAJ0B,EAK1BE,wBAL0B,CAA9B,EAQA;AACA;;AACA,QAAIE,OAAJ;;AACA,QAAI;AACAA,aAAO,GAAG,MAAM,wBAAWX,UAAX,EAAuBU,eAAvB,EAAwCL,UAAxC,EAAoDE,SAApD,CAAhB;AACH,KAFD,CAEE,OAAOK,KAAP,EAAuB;AACrB;AACA;AACA;AACA,UAAIA,KAAK,YAAYC,kCAAjB,IAA8CD,KAAK,YAAYC,sCAAnE,EAAkG;AAC9F;AACA,YAAI;AACA,gBAAMC,WAAW,GAAG,IAAIC,qBAAJ,GAAkBC,GAAlB,CAChB,qDACIf,KAAK,CAACgB,SADV,EAEIP,eAFJ,EAGIP,KAHJ,EAIID,IAJJ,EAKIK,SALJ,EAMIE,wBANJ,CADgB,CAApB;AAWA,gBAAM,yCAA0BT,UAA1B,EAAsCc,WAAtC,EAAmD,CAACb,KAAD,CAAnD,EAA4DK,cAA5D,CAAN;AACH,SAbD,CAaE,OAAOM,KAAP,EAAuB,CACrB;AACA;AACH,SAlB6F,CAoB9F;;;AACAD,eAAO,GAAG,MAAM,wBAAWX,UAAX,EAAuBU,eAAvB,EAAwCL,UAAxC,EAAoDE,SAApD,CAAhB;AACH,OAtBD,MAsBO;AACH,cAAMK,KAAN;AACH;AACJ;;AAED,QAAI,CAACD,OAAO,CAACT,IAAR,CAAagB,MAAb,CAAoBhB,IAApB,CAAL,EAAgC,MAAM,IAAIW,8BAAJ,EAAN;AAChC,QAAI,CAACF,OAAO,CAACR,KAAR,CAAce,MAAd,CAAqBf,KAArB,CAAL,EAAkC,MAAM,IAAIU,+BAAJ,EAAN;AAElC,WAAOF,OAAP;AACH;AAAA;;AA3DDQ","names":["getOrCreateAssociatedTokenAccount","connection","payer","mint","owner","allowOwnerOffCurve","commitment","confirmOptions","programId","constants_1","associatedTokenProgramId","associatedToken","account","error","errors_1","transaction","web3_js_1","add","publicKey","equals","exports"],"sources":["/home/rajeev/Internship/Get-NFTs-in-Wallet-Adapter/node_modules/@solana/spl-token/src/actions/getOrCreateAssociatedTokenAccount.ts"],"sourcesContent":["import {\n    Commitment,\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n} from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/index';\nimport { Account, getAccount, getAssociatedTokenAddress } from '../state/index';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const associatedToken = await getAssociatedTokenAddress(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId\n                    )\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n"]},"metadata":{},"sourceType":"script"}