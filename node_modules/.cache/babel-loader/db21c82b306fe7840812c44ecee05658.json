{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMinimumBalanceForRentExemptAccount = exports.getAccount = exports.ACCOUNT_SIZE = exports.AccountLayout = exports.AccountState = void 0;\n\nconst buffer_layout_1 = require(\"@solana/buffer-layout\");\n\nconst buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\n\nconst constants_1 = require(\"../constants\");\n\nconst errors_1 = require(\"../errors\");\n/** Token account state as stored by the program */\n\n\nvar AccountState;\n\n(function (AccountState) {\n  AccountState[AccountState[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  AccountState[AccountState[\"Initialized\"] = 1] = \"Initialized\";\n  AccountState[AccountState[\"Frozen\"] = 2] = \"Frozen\";\n})(AccountState = exports.AccountState || (exports.AccountState = {}));\n/** Buffer layout for de/serializing a token account */\n\n\nexports.AccountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)('mint'), (0, buffer_layout_utils_1.publicKey)('owner'), (0, buffer_layout_utils_1.u64)('amount'), (0, buffer_layout_1.u32)('delegateOption'), (0, buffer_layout_utils_1.publicKey)('delegate'), (0, buffer_layout_1.u8)('state'), (0, buffer_layout_1.u32)('isNativeOption'), (0, buffer_layout_utils_1.u64)('isNative'), (0, buffer_layout_utils_1.u64)('delegatedAmount'), (0, buffer_layout_1.u32)('closeAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('closeAuthority')]);\n/** Byte length of a token account */\n\nexports.ACCOUNT_SIZE = exports.AccountLayout.span;\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\n\nfunction getAccount(connection, address, commitment) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, function* () {\n    const info = yield connection.getAccountInfo(address, commitment);\n    if (!info) throw new errors_1.TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new errors_1.TokenInvalidAccountOwnerError();\n    if (info.data.length != exports.ACCOUNT_SIZE) throw new errors_1.TokenInvalidAccountSizeError();\n    const rawAccount = exports.AccountLayout.decode(info.data);\n    return {\n      address,\n      mint: rawAccount.mint,\n      owner: rawAccount.owner,\n      amount: rawAccount.amount,\n      delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n      delegatedAmount: rawAccount.delegatedAmount,\n      isInitialized: rawAccount.state !== AccountState.Uninitialized,\n      isFrozen: rawAccount.state === AccountState.Frozen,\n      isNative: !!rawAccount.isNativeOption,\n      rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n      closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null\n    };\n  });\n}\n\nexports.getAccount = getAccount;\n/** Get the minimum lamport balance for a token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nfunction getMinimumBalanceForRentExemptAccount(connection, commitment) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return yield connection.getMinimumBalanceForRentExemption(exports.ACCOUNT_SIZE, commitment);\n  });\n}\n\nexports.getMinimumBalanceForRentExemptAccount = getMinimumBalanceForRentExemptAccount;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAEA;;AACA;AA+BA;;;AACA,IAAYA,YAAZ;;AAAA,WAAYA,YAAZ,EAAwB;AACpBA;AACAA;AACAA;AACH,CAJD,EAAYA,YAAY,GAAZC,gDAAY,EAAZ,CAAZ;AAqBA;;;AACaA,wBAAgB,4BAAmB,CAC5C,qCAAU,MAAV,CAD4C,EAE5C,qCAAU,OAAV,CAF4C,EAG5C,+BAAI,QAAJ,CAH4C,EAI5C,yBAAI,gBAAJ,CAJ4C,EAK5C,qCAAU,UAAV,CAL4C,EAM5C,wBAAG,OAAH,CAN4C,EAO5C,yBAAI,gBAAJ,CAP4C,EAQ5C,+BAAI,UAAJ,CAR4C,EAS5C,+BAAI,iBAAJ,CAT4C,EAU5C,yBAAI,sBAAJ,CAV4C,EAW5C,qCAAU,gBAAV,CAX4C,CAAnB,CAAhB;AAcb;;AACaA,uBAAeA,sBAAcC,IAA7B;AAEb;;;;;;;;;;;AAUA,SAAsBC,UAAtB,CACIC,UADJ,EAEIC,OAFJ,EAGIC,UAHJ,EAIgC;AAAA,MAA5BC,SAA4B,uEAAhBC,4BAAgB;;AAE5B,UAAMC,IAAI,GAAG,MAAML,UAAU,CAACM,cAAX,CAA0BL,OAA1B,EAAmCC,UAAnC,CAAnB;AACA,QAAI,CAACG,IAAL,EAAW,MAAM,IAAIE,kCAAJ,EAAN;AACX,QAAI,CAACF,IAAI,CAACG,KAAL,CAAWC,MAAX,CAAkBN,SAAlB,CAAL,EAAmC,MAAM,IAAII,sCAAJ,EAAN;AACnC,QAAIF,IAAI,CAACK,IAAL,CAAUC,MAAV,IAAoBd,oBAAxB,EAAsC,MAAM,IAAIU,qCAAJ,EAAN;AAEtC,UAAMK,UAAU,GAAGf,sBAAcgB,MAAd,CAAqBR,IAAI,CAACK,IAA1B,CAAnB;AAEA,WAAO;AACHT,aADG;AAEHa,UAAI,EAAEF,UAAU,CAACE,IAFd;AAGHN,WAAK,EAAEI,UAAU,CAACJ,KAHf;AAIHO,YAAM,EAAEH,UAAU,CAACG,MAJhB;AAKHC,cAAQ,EAAEJ,UAAU,CAACK,cAAX,GAA4BL,UAAU,CAACI,QAAvC,GAAkD,IALzD;AAMHE,qBAAe,EAAEN,UAAU,CAACM,eANzB;AAOHC,mBAAa,EAAEP,UAAU,CAACQ,KAAX,KAAqBxB,YAAY,CAACyB,aAP9C;AAQHC,cAAQ,EAAEV,UAAU,CAACQ,KAAX,KAAqBxB,YAAY,CAAC2B,MARzC;AASHC,cAAQ,EAAE,CAAC,CAACZ,UAAU,CAACa,cATpB;AAUHC,uBAAiB,EAAEd,UAAU,CAACa,cAAX,GAA4Bb,UAAU,CAACY,QAAvC,GAAkD,IAVlE;AAWHG,oBAAc,EAAEf,UAAU,CAACgB,oBAAX,GAAkChB,UAAU,CAACe,cAA7C,GAA8D;AAX3E,KAAP;AAaH;AAAA;;AA1BD9B;AA4BA;;;;;;;;AAOA,SAAsBgC,qCAAtB,CACI7B,UADJ,EAEIE,UAFJ,EAE2B;;AAEvB,WAAO,MAAMF,UAAU,CAAC8B,iCAAX,CAA6CjC,oBAA7C,EAA2DK,UAA3D,CAAb;AACH;AAAA;;AALDL","names":["AccountState","exports","span","getAccount","connection","address","commitment","programId","constants_1","info","getAccountInfo","errors_1","owner","equals","data","length","rawAccount","decode","mint","amount","delegate","delegateOption","delegatedAmount","isInitialized","state","Uninitialized","isFrozen","Frozen","isNative","isNativeOption","rentExemptReserve","closeAuthority","closeAuthorityOption","getMinimumBalanceForRentExemptAccount","getMinimumBalanceForRentExemption"],"sources":["/home/rajeev/Internship/Get-NFTs-in-Wallet-Adapter/node_modules/@solana/spl-token/src/state/account.ts"],"sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors';\n\n/** Information about a token account */\nexport interface Account {\n    /** Address of the account */\n    address: PublicKey;\n    /** Mint associated with the account */\n    mint: PublicKey;\n    /** Owner of the account */\n    owner: PublicKey;\n    /** Number of tokens the account holds */\n    amount: bigint;\n    /** Authority that can transfer tokens from the account */\n    delegate: PublicKey | null;\n    /** Number of tokens the delegate is authorized to transfer */\n    delegatedAmount: bigint;\n    /** True if the account is initialized */\n    isInitialized: boolean;\n    /** True if the account is frozen */\n    isFrozen: boolean;\n    /** True if the account is a native token account */\n    isNative: boolean;\n    /**\n     * If the account is a native token account, it must be rent-exempt. The rent-exempt reserve is the amount that must\n     * remain in the balance until the account is closed.\n     */\n    rentExemptReserve: bigint | null;\n    /** Optional authority to close the account */\n    closeAuthority: PublicKey | null;\n}\n\n/** Token account state as stored by the program */\nexport enum AccountState {\n    Uninitialized = 0,\n    Initialized = 1,\n    Frozen = 2,\n}\n\n/** Token account as stored by the program */\nexport interface RawAccount {\n    mint: PublicKey;\n    owner: PublicKey;\n    amount: bigint;\n    delegateOption: 1 | 0;\n    delegate: PublicKey;\n    state: AccountState;\n    isNativeOption: 1 | 0;\n    isNative: bigint;\n    delegatedAmount: bigint;\n    closeAuthorityOption: 1 | 0;\n    closeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a token account */\nexport const AccountLayout = struct<RawAccount>([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    u32('delegateOption'),\n    publicKey('delegate'),\n    u8('state'),\n    u32('isNativeOption'),\n    u64('isNative'),\n    u64('delegatedAmount'),\n    u32('closeAuthorityOption'),\n    publicKey('closeAuthority'),\n]);\n\n/** Byte length of a token account */\nexport const ACCOUNT_SIZE = AccountLayout.span;\n\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getAccount(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const info = await connection.getAccountInfo(address, commitment);\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawAccount = AccountLayout.decode(info.data);\n\n    return {\n        address,\n        mint: rawAccount.mint,\n        owner: rawAccount.owner,\n        amount: rawAccount.amount,\n        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n        delegatedAmount: rawAccount.delegatedAmount,\n        isInitialized: rawAccount.state !== AccountState.Uninitialized,\n        isFrozen: rawAccount.state === AccountState.Frozen,\n        isNative: !!rawAccount.isNativeOption,\n        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n    };\n}\n\n/** Get the minimum lamport balance for a token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccount(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(ACCOUNT_SIZE, commitment);\n}\n"]},"metadata":{},"sourceType":"script"}